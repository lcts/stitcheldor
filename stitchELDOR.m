function [ data, params ] = stitchELDOR(varargin)
% stitch together two ELDOR time traces
%
% USAGE:
% data = stitcheldor(x_short, y_short, x_long, y_long)
% [data params] = stitcheldor(x_short, y_short, x_long, y_long)
%
% input y data should be complex to allow phase correction,
% otherwise phase-correction will be deactivated
%
% INPUTS:
% x/y_short/long: data to be stitched
% autophase:      true or false, perform phase-correction
% offset:         in ns, shift splitpoint manually, default 0
%                 'offset' is defined negative, i.e a positive value shifts the
%                 splitpoint towards 0ns
%
% OUTPUTS:
% data:   A struct containing the original data (phase-corrected) in data.short
%         and data.long, the stitched data with stitched x axis in data.stitched
%         and the stitched data with interpolated x axis in data.interp
% params: parameters generated by the program, like phase corrections applied
%         and scaling used
%
p = inputParser;
p.addRequired('x_short', @(x)validateattributes(x,{'numeric'},{'vector'}));
p.addRequired('y_short', @(x)validateattributes(x,{'numeric'},{'vector'}));
p.addRequired('x_long',  @(x)validateattributes(x,{'numeric'},{'vector'}));
p.addRequired('y_long',  @(x)validateattributes(x,{'numeric'},{'vector'}));
p.addParamValue('autophase', true, @(x)validateattributes(x,{'logical'},{'scalar', 'nonnegative'}));
p.addParamValue('offset', 0, @(x)validateattributes(x,{'numeric'},{'scalar'}));
p.FunctionName = 'stitchELDOR';
p.parse(varargin{:});

VERSION = '0.8';
fprintf('\nstitchELDOR v%s\n', VERSION);

% save x axes in output
data.short.x = p.Results.x_short;
data.long.x  = p.Results.x_long;

% find splitpoints for short.x and long.x
[~, params.short.split.index] = min(abs(data.short.x - (data.short.x(end) - p.Results.offset)));
[~, params.long.split.index] = min(abs(data.long.x - data.short.x(params.short.split.index)));
params.short.split.value = data.short.x(params.short.split.index);
% shift by one if the found index is on the wrong side due to min(abs(...))
if data.long.x(params.long.split.index) <= params.short.split.value
  params.long.split.index = params.long.split.index + 1;
end
params.long.split.value = data.long.x(params.long.split.index);

% generate stitched and interpolated x axes
data.stitched.x = [ data.short.x(1:params.short.split.index); data.long.x(params.long.split.index:end) ];
data.interp.x   = (data.short.x(1):data.short.x(2)-data.short.x(1):data.long.x(end))';

% phase-correct y data if needed and data complex
if ~isreal(p.Results.y_short) && p.Results.autophase
  [ data.short.y params.short.phase params.short.phaseoffset params.short.phasedeviation] = autophase(p.Results.y_short);
  data.short.y = data.short.y - params.short.phaseoffset*i;
else
  data.short.y = p.Results.y_short;
  params.short.phase = false;
end
if ~isreal(p.Results.y_long) && p.Results.autophase
  [ data.long.y params.long.phase params.long.phaseoffset params.long.phasedeviation]  = autophase(p.Results.y_long);
  data.long.y = data.long.y - params.long.phaseoffset*i;
else
  data.long.y  = p.Results.y_long;
  params.long.phase  = false;
end

% interpolate long.y at points short.x
data.interp.y = interp1(data.long.x, data.long.y, data.short.x);

% fit interp.y to short.y
f = @(x)sum((real(data.short.y) - (x(1)*real(data.interp.y) + x(2))).^2);
ab = fminsearch(f,[1 0]);

% save parameters
params.scaling = ab(1);
params.offset = ab(2);

% scale data.long.y and stitch it
data.stitched.y = params.scaling * data.long.y + params.offset;
data.stitched.y = [ data.short.y(1:params.short.split.index); data.stitched.y(params.long.split.index:end) ];
% as well as interpolate it at points interp.x
data.interp.y = interp1(data.stitched.x, data.stitched.y, data.interp.x);
