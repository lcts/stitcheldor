function [ data, params ] = stitcheldor(varargin)
% stitch together two ELDOR time traces
%
% USAGE:
% data = stitcheldor(datashort_x, datashort_y, datalong_x, datalong_y)
% [data params] = stitcheldor(datashort_x, datashort_y, datalong_x, datalong_y)
%
% input y data should be complex to allow phase correction,
% otherwise phase-correction will be deactivated
%
% INPUTS:
% datashort/long_x/y: data to be stitched
% autophase:          boolean, perform phase-correction
%
% OUTPUTS:
% data:   A struct containing the original data (phase-corrected) in data.short
%         and data.long, the stitched data with stitched x axis in data.stitched
%         and the stitched data with interpolated x axis in data.interp
% params: parameters generated by the program like phase corrections applied
%         and scaling used
%
p = inputParser;
p.addRequired('x_short', @(x)validateattributes(x,{'numeric'},{'vector'}));
p.addRequired('y_short', @(x)validateattributes(x,{'numeric'},{'vector'}));
p.addRequired('x_long', @(x)validateattributes(x,{'numeric'},{'vector'}));
p.addRequired('y_long', @(x)validateattributes(x,{'numeric'},{'vector'}));
p.addParamValue('autophase', true, @(x)validateattributes(x,{'logical'},{'scalar'}));
p.FunctionName = 'stitcheldor';
p.parse(varargin{:});

% save x axes in output
data.short.x = p.Results.x_short;
data.long.x  = p.Results.x_long;

% find splitpoint as minimum of xlong - max(xshort)
[~,  params.split.index] = min(abs(data.long.x - max(data.short.x)));
% shift by one if the found index is on the wrong side
if data.long.x(params.split.index) <= data.short.x(end)
  params.split.index = params.split.index + 1;
end
params.split.value = data.long.x(params.split.index)

% generate stitched and interpolated x axes
data.stitched.x = [ data.short.x; data.long.x(params.split.index:end) ];
data.interp.x   = (data.short.x(1):data.short.x(2)-data.short.x(1):data.long.x(end))';

% phase-correct y data if needed and data complex
if p.Results.autophase && ~isreal(p.Results.y_short) && ~isreal(p.Results.y_long)
  [ data.short.y params.short.phase params.short.phasedeviation] = autophase(p.Results.y_short);
  [ data.long.y  params.long.phase  params.long.phasedeviation]  = autophase(p.Results.y_long);
  disp('complex')
else
  data.short.y = p.Results.y_short;
  data.long.y  = p.Results.y_long;
  params.short.phase = false;
  params.long.phase  = false;
  disp('real')
end

% interpolate ylong to indices of xshort
data.interp.y = interp1(data.long.x, data.long.y, data.short.x);

% fit one dataset to the other
f = @(x)sum((real(data.short.y) - (x(1)*real(data.interp.y) + x(2))).^2);
ab = fminsearch(f,[1 0]);

% save parameters
params.scaling = ab(1);
params.offset = ab(2);

% scale data.long.y and stitch it
data.stitched.y = params.scaling * data.long.y + params.offset;
data.stitched.y = [ data.short.y; data.stitched.y(params.split.index:end) ];
data.interp.y = interp1(data.stitched.x, data.stitched.y, data.interp.x);
